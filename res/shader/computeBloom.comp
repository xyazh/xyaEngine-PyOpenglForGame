#version 430

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgba32f) readonly uniform image2D inputImage;
layout (binding = 1, rgba32f) uniform image2D pingpongImage1;
layout (binding = 2, rgba32f) uniform image2D pingpongImage2;
layout (binding = 3, rgba32f) uniform image2D downImage1;
layout (binding = 4, rgba32f) uniform image2D downImage2;
layout (binding = 5, rgba32f) uniform image2D outImage;

uniform int mode;
uniform ivec2 p2Size;

// 高斯半径和卷积核
const int RADIUS = 5;
const float weights[6] = float[6](
    0.16397, 0.15136, 0.11906, 0.07981, 0.04559, 0.02219
);


void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    ivec2 inSize = imageSize(inputImage);
    ivec2 p1Size = imageSize(pingpongImage1);
    ivec2 p2Size = imageSize(pingpongImage2);
    ivec2 downSize1 = imageSize(downImage1);
    ivec2 downSize2 = imageSize(downImage2);
    ivec2 o = imageSize(outImage);
    if (mode == 0) {
        // 转化为百分比位置
        vec2 uv = vec2(gid) / vec2(downSize1);
        // 还原为原图像素位置
        ivec2 inPos = ivec2(uv * vec2(inSize));
        // 取样点偏移（中心 + 四角）
        int range = 1;
        ivec2 offsets[5] = ivec2[5](
            ivec2(0, 0),
            ivec2(-range, -range),
            ivec2(+range, +range),
            ivec2(-range, +range),
            ivec2(+range, -range)
        );
        vec4 sum = vec4(0.0);
        int count = 0;
        for (int i = 0; i < 5; i++) {
            ivec2 pos = clamp(inPos + offsets[i], ivec2(0), inSize - ivec2(1));
            sum += imageLoad(inputImage, pos);
            count++;
        }
        imageStore(downImage1, gid, sum / float(count));
    }
    else if (mode == 1) {
        // gid 当前线程在 pingpongImage1 中的位置
        if (gid.x >= p1Size.x || gid.y >= p1Size.y) return;
        // 计算在 downImage1 的浮点坐标
        vec2 uv = vec2(gid) / vec2(p1Size);          // [0,1] 范围
        vec2 downCoord = uv * vec2(downSize1) - 0.5; // 下采样像素坐标，-0.5 对齐中心
        ivec2 i0 = ivec2(floor(downCoord));
        ivec2 i1 = i0 + ivec2(1, 0);
        ivec2 i2 = i0 + ivec2(0, 1);
        ivec2 i3 = i0 + ivec2(1, 1);
        // clamp 防止越界
        i0 = clamp(i0, ivec2(0), downSize1 - 1);
        i1 = clamp(i1, ivec2(0), downSize1 - 1);
        i2 = clamp(i2, ivec2(0), downSize1 - 1);
        i3 = clamp(i3, ivec2(0), downSize1 - 1);
        vec2 f = fract(downCoord); // 小数部分，用于插值
        // 双线性插值
        vec4 c00 = imageLoad(downImage1, i0);
        vec4 c10 = imageLoad(downImage1, i1);
        vec4 c01 = imageLoad(downImage1, i2);
        vec4 c11 = imageLoad(downImage1, i3);
        vec4 c0 = mix(c00, c10, f.x);
        vec4 c1 = mix(c01, c11, f.x);
        vec4 c = mix(c0, c1, f.y);
        imageStore(pingpongImage1, gid, c);
    }
    else if (mode == 2) {
        vec4 blurColor = vec4(0.0);
        float totalWeight = 0.0;
        for (int i = -RADIUS; i <= RADIUS; i++){
            ivec2 offset = gid + ivec2(i, 0);
            ivec2 pos = clamp(offset, ivec2(0), p1Size - ivec2(1));
            float w = weights[abs(i)];
            blurColor += imageLoad(pingpongImage1, pos) * w;
            totalWeight += w;
        }
        blurColor /= totalWeight;
        imageStore(pingpongImage2, gid, blurColor);
    }else if (mode == 3) {
        vec4 blurColor = vec4(0.0);
        float totalWeight = 0.0;
        for (int i = -RADIUS; i <= RADIUS; i++){
            ivec2 offset = gid + ivec2(0, i);
            ivec2 pos = clamp(offset, ivec2(0), p2Size - ivec2(1));
            float w = weights[abs(i)];
            blurColor += imageLoad(pingpongImage2, pos) * w;
            totalWeight += w;
        }
        blurColor /= totalWeight;
        imageStore(pingpongImage1, gid, blurColor);
    }else if (mode == 4) {
        vec4 blurColor = vec4(0.0);
        float totalWeight = 0.0;
        for (int i = -RADIUS; i <= RADIUS; i++){
            ivec2 offset = gid + ivec2(i, 0);
            ivec2 pos = clamp(offset, ivec2(0), downSize1 - ivec2(1));
            float w = weights[abs(i)];
            blurColor += imageLoad(downImage1, pos) * w;
            totalWeight += w;
        }
        blurColor /= totalWeight;
        imageStore(downImage2, gid, blurColor);
    }else if (mode == 5) {
        vec4 blurColor = vec4(0.0);
        float totalWeight = 0.0;
        for (int i = -RADIUS; i <= RADIUS; i++){
            ivec2 offset = gid + ivec2(0, i);
            ivec2 pos = clamp(offset, ivec2(0), downSize2 - ivec2(1));
            float w = weights[abs(i)];
            blurColor += imageLoad(downImage2, pos) * w;
            totalWeight += w;
        }
        blurColor /= totalWeight;
        imageStore(downImage1, gid, blurColor);
    }else if (mode == 6){
        ivec2 outSize = imageSize(outImage);
        if (gid.x >= outSize.x || gid.y >= outSize.y) return;
        // 计算在 pingpongImage1 中的浮点坐标
        vec2 uv = vec2(gid) / vec2(outSize);          // [0,1] 范围
        vec2 pingCoord = uv * vec2(p1Size) - 0.5;
        ivec2 i0 = ivec2(floor(pingCoord));
        ivec2 i1 = i0 + ivec2(1, 0);
        ivec2 i2 = i0 + ivec2(0, 1);
        ivec2 i3 = i0 + ivec2(1, 1);
        // clamp 防止越界
        i0 = clamp(i0, ivec2(0), p1Size - 1);
        i1 = clamp(i1, ivec2(0), p1Size - 1);
        i2 = clamp(i2, ivec2(0), p1Size - 1);
        i3 = clamp(i3, ivec2(0), p1Size - 1);
        vec2 f = fract(pingCoord);
        // 双线性插值
        vec4 c00 = imageLoad(pingpongImage1, i0);
        vec4 c10 = imageLoad(pingpongImage1, i1);
        vec4 c01 = imageLoad(pingpongImage1, i2);
        vec4 c11 = imageLoad(pingpongImage1, i3);
        vec4 pingColor = mix(mix(c00, c10, f.x), mix(c01, c11, f.x), f.y);
        // 读取 inputImage
        ivec2 inPos = clamp(gid, ivec2(0), inSize - 1);
        vec4 inputColor = imageLoad(inputImage, inPos);
        // 合并方式示例：简单相加
        vec3 outColor = (pingColor.rgb + inputColor.rgb);
        imageStore(outImage, gid, vec4(outColor,1.0));
    }
}
